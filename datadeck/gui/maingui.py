__author__ = 'dgraziotin'
"""
Main GUI module. Implements search and download of packages.
Calls packagegui.py for displaying information about a package.
Manages Operations (~threads, see operations.py) and their messages.
Coding standard: http://www.wxpython.org/codeguidelines.php
"""
import threading
import wx
import wx.xrc
import wx.lib.newevent
import datadeck.operations as operations
import packagegui
import shutil
import os
import datadeck.settings as settings
import datadeck.operations as operations
import dpm.package
import datadeck.validator
import util
import consoleutil
import operationsutil
import downloadutil

import base
# for handling stdout and stderr on a TextCtrl
WX_STDOUT, EVT_STDOUT = wx.lib.newevent.NewEvent()

class MainGUI(base.DataDeckFrame):
    """
    The first GUI displayed when the program starts up.
    """

    def __init__(self):
        """
        Loads resources from XRC file, prepares internal structures representing search results,
        binds events, prepares the Console for receiving stdout and stderr.
        """
        base.DataDeckFrame.__init__(self, None)

        #not handled well in autogenerated code, so they will be set here.

        # search results
        self.m_search_results = {}
        self.m_search_results_index = 0

        self.m_search_results_list.InsertColumn(0, "Name")
        self.m_search_results_list.InsertColumn(1, "Short Description")
        self.m_search_results_list.InsertColumn(2, "License")

        self.m_console = consoleutil.ConsoleUtil(self)
        self.m_operations = operationsutil.OperationsUtil(self)
        self.m_download = downloadutil.DownloadUtil(self)

        self.m_console_text_timer = wx.Timer(self.m_console_text, -1)
        self.m_console_text.Bind(EVT_STDOUT, self.OnUpdateConsole)
        self.m_console_text.Bind(wx.EVT_TIMER, self.OnProcessPendingEventsConsole)

        self.license_choice.AppendItems(settings.Settings.licenses())
        self.destination_dirpicker.SetPath(settings.Settings.datadeck_default_path())



        # Set up event handler for any worker thread results
        operations.OPERATION_MESSAGE_HANDLER(self, self.OnOperationMessageReceived)

        # disable Download and Info buttons
        self.EnableButtons(False)
        self.SetSize(wx.Size(600, 650))
        self.Show(True)

    def OnButtonCreateClick( self, event ):
        p = dpm.package.Package()
        p.name = self.name_text.GetValue()
        p.title = p.name
        p.url = self.url_text.GetValue()
        p.license = settings.Settings.licenses(self.license_choice.GetSelection())
        p.author = self.author_text.GetValue()
        p.author_email = self.author_email_text.GetValue()
        p.notes = self.notes_text.GetValue()
        tags = self.tags_text.GetValue()
        p.tags = tags.split(" ")
        try:
            datadeck.validator.PackageValidator.validate(p)
        except datadeck.validator.PackageNonValid, e:
            wx.MessageBox(str(e), caption="Validation Error", style=wx.OK)
            return

        path = self.destination_dirpicker.GetPath()
        operations.InitAndSaveOperation(self, p, path)

    def OnNameTextKillFocus( self, event ):
        name = self.name_text.GetValue()
        path = self.destination_dirpicker.GetPath()
        if not name or not path:
            return
        if datadeck.validator.PackageValidator.already_existing(path, name):
            print "WARNING: a package named " + name + " already exists. You will overwrite it."

    def OnConsoleKillButtonClick(self, event):
        """
        Kill all the currently running Operations
        """
        self.m_console.OnConsoleKillButtonClick(event)


    def OnUpdateConsole(self, event):
        """
        Update the Console text
        """
        self.m_console.OnUpdateConsole(event)

    def OnProcessPendingEventsConsole(self, event):
        """
        Handle pending events
        """
        self.m_console.OnProcessPendingEventsConsole(event)


    def OnOperationMessageReceived(self, operation_message):
        """
        Handler for Operation Messages. Detect the type of the Message received and take care of it.
        According to the status of the Message, inform the user and update the GUI.
        See operations.py
        """
        self.m_operations.OnOperationMessageReceived(operation_message)

    def OnSearchTextKeyDown(self, event):
        """
        Simulate a click on Search button when Return is pressed
        """
        key_code = event.GetKeyCode()
        if key_code == wx.WXK_RETURN:
            self.OnButtonSearchClick(event)
        event.Skip()

    def OnSearchResultsListItemSelected( self, event ):
        """
        If the user selects a package in the search result list,
        enable the Info and Download buttons, for processing it.
        """
        selected_item = event.m_itemIndex
        package_selected = self.m_search_results[selected_item]
        if package_selected:
            self.EnableButtons(True)

    def CleanSearchResults(self):
        """
        Clear both the GUI and the internal lists of packages found. Ready for a new search.
        """
        self.m_search_results_list.DeleteAllItems()
        self.m_search_results_index = 0
        self.m_search_results = {}

    def OnButtonSearchClick( self, event ):
        """
        If there is text in the search text, launch a SearchOperation.
        """
        searched_value = self.m_search_text.GetValue()

        if not searched_value:
            return

        # clean eventual previous results
        self.EnableButtons(False)
        self.CleanSearchResults()

        print "Please wait..."

        operations.SearchOperation(self, searched_value)


    def OnButtonDownloadClick(self, event):
        """
        Retrieve the currently selected package in the results list and launch a DownloadOperation
        for downloading it.
        """
        #TODO block downloads if there is already one in downloading
        package_selected_index = self.m_search_results_list.GetNextSelected(-1)
        if package_selected_index == -1:
            return

        package_selected = self.m_search_results[package_selected_index]
        download_dir = self.m_download.DownloadDirDialog()

        if not download_dir:
            return

        package_path = download_dir + os.sep + package_selected.name

        overwrite_check = self.m_download.CheckPackageOverwrite(download_dir, package_selected)

        if overwrite_check:
            operations.DownloadOperation(self, package_selected, download_dir)


    def OnButtonInfoClick(self, event):
        """
        Retrieve the currently selected package in the results list and invoke the Package GUI
        for displaying information about it.
        """
        package_selected_index = self.m_search_results_list.GetNextSelected(-1)
        if package_selected_index == -1:
            return

        package_selected = self.m_search_results[package_selected_index]

        if package_selected:
            package_info = packagegui.PackageGUI(self, package_selected)
            package_info.SetSize(wx.Size(500, 500))
            package_info.Center()
            package_info.Show(True)
        return

    def OnConsoleClearButtonClick(self, event):
        self.m_console.OnConsoleClearButtonClick(event)

    def EnableButtons(self, enable):
        """
        Could not find a better name. Take care of two buttons that user sometimes do not need to click.
        Info and Download button can not be clicked if there are no packages selected. Their respective Click events
        take care whether there is a package selected or not, but in this way we drive the user experience, letting
        him/her know what to do after a package is searched.
        """
        self.m_info_button.Enable(enable)
        self.m_download_button.Enable(enable)


    def InsertSearchResultsList(self, package):
        """
        Insert a package in both the internal list and the GUI list. self.m_search_results_index ensures us that
        the two lists will be consistent.
        """
        self.m_search_results[self.m_search_results_index] = package

        name = package.metadata['name'] if package.metadata['name'] else "N/A"
        notes = package.metadata['notes'] if package.metadata['notes'] else "N/A"
        license = package.metadata['license'] if package.metadata['license'] else "N/A"

        self.m_search_results_list.InsertStringItem(self.m_search_results_index, name)

        self.m_search_results_list.SetStringItem(self.m_search_results_index, 1,
            notes[:30].replace("\n", " ").replace("\r", " "))
        self.m_search_results_list.SetStringItem(self.m_search_results_index, 2, license)

        self.m_search_results_list.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.m_search_results_list.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.m_search_results_list.SetColumnWidth(2, wx.LIST_AUTOSIZE)


    def OnMenuAboutClick(self, event):
        """
        Creates the About window.
        """
        import datadeck

        about_frame = base.AboutFrame(self)
        label = "DataDeck v%s" % datadeck.__version__

        about_frame.datadeck_label.SetLabel(label)

        license = datadeck.__license_full__
        about_frame.license_text.AppendText(license)

        about_frame.SetSize(wx.Size(500, 400))
        about_frame.Centre()
        about_frame.Show()


    def OnMenuClickExit(self, event):
        self.m_operations.KillOperations()
        self.Close()

    def OnMenuSettingsClick(self, event):
        import settingsgui

        settings = settingsgui.SettingsGUI(self)
        settings.Show()


    def CheckConfig(self):
        #TODO: remove it when dpm 0.10 is officially released
        configuration = dpm.CONFIG
        if configuration.get("index:ckan", "ckan.url").find('ckan.net') > -1:
            configuration.set("index:ckan", "ckan.url", "http://thedatahub.org/api/")
            configuration.write(open(dpm.config.default_config_path, 'w'))

            configuration_path = dpm.config.default_config_path
            message = ("A dpm configuration file has been created on %s\n" +
                       "Please restart the program.") % (configuration_path)
            box = wx.MessageDialog(self, message, "dpm Configuration", wx.OK)
            box.ShowModal()
            box.Destroy()
            self.Close()
        import ConfigParser

        default_path = ""
        try:
            default_path = settings.Settings.datadeck_default_path()
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            settings.Settings.datadeck_default_path(os.path.expanduser('~'))
        if not default_path:
            settings.Settings.datadeck_default_path(os.path.expanduser('~'))
