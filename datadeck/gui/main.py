__author__ = 'dgraziotin'
"""
Main GUI module. Implements search and download of packages.
Calls packagegui.py for displaying information about a package.
Manages Operations (~threads, see operations.py) and their messages.
Coding standard: http://www.wxpython.org/codeguidelines.php
"""
import os
import wx
import wx.xrc
import wx.lib.newevent
import dpm.package
import datadeck
import datadeck.settings
import datadeck.operations

import util.console
import util.operations
import util.download
import util.search
import util.package

import base
import settings


# for handling stdout and stderr on a TextCtrl
WX_STDOUT, EVT_STDOUT = wx.lib.newevent.NewEvent()

class MainGUI(base.DataDeckFrame):
    """
    The first GUI displayed when the program starts up.
    """

    def __init__(self):
        """
        Loads resources from XRC file, prepares internal structures representing search results,2
        """
        base.DataDeckFrame.__init__(self, None)

        self.CheckConfig()

        self.notebook_tabs = {
            "library" : 0,
            "search" : 1,
            "create" : 2,
        }

        #not handled well in autogenerated code, so they will be set here.

        self.m_search_results_listctrl.InsertColumn(0, "Name")
        self.m_search_results_listctrl.InsertColumn(1, "Short Description")
        self.m_search_results_listctrl.InsertColumn(2, "License")

        self.m_library_listctrl.InsertColumn(0, "Name")
        self.m_library_listctrl.InsertColumn(1, "Short Description")
        self.m_library_listctrl.InsertColumn(2, "License")

        self.m_console = util.console.ConsoleUtil(self)
        self.m_operations = util.operations.OperationsUtil(self)
        self.m_download = util.download.DownloadUtil(self)
        self.m_package = util.package.PackageUtil(self)
        self.m_search_results = util.package.SearchResults(self.m_search_results_listctrl)
        self.m_library = util.package.Library(self.m_library_listctrl)

        self.m_console_text_timer = wx.Timer(self.m_console_text, -1)
        self.m_console_text.Bind(EVT_STDOUT, self.OnUpdateConsole)
        self.m_console_text.Bind(wx.EVT_TIMER, self.OnProcessPendingEventsConsole)

        self.license_choice.AppendItems(self.m_package.Licenses())
        self.destination_dirpicker.SetPath(datadeck.settings.Settings.datadeck_default_path())

        # Set up event handler for any worker thread results
        datadeck.operations.OPERATION_MESSAGE_HANDLER(self, self.OnOperationMessageReceived)

        # disable Download and Info buttons
        self.EnableSearchResultsButtons(False)
        self.SetSize(wx.Size(600, 650))
        self.Show(True)

    # <menu>
    def OnMenuNewClick( self, event ):
        self.name_text.Clear()
        self.url_text.Clear()
        self.license_choice.Clear()
        self.author_text.Clear()
        self.author_email_text.Clear()
        self.notes_text.Clear()
        self.tags_text.Clear()
        self.destination_dirpicker.SetPath(datadeck.settings.Settings.datadeck_default_path())
        self.m_notebook.ChangeSelection(self.notebook_tabs["create"])

    def OnMenuOpenClick( self, event ):
        open_path = self.m_download.DownloadDirDialog(message="Select a Package folder")
        if not open_path:
            return
        package = self.m_package.Open(open_path)
        if not package:
            return
        self.PopulatePackageCreation(package)
        self.m_notebook.ChangeSelection(self.notebook_tabs["create"])

    def OnMenuSettingsClick(self, event):
        settings.SettingsGUI(self).Show()

    def OnMenuExitClick(self, event):
        self.m_operations.KillOperations()
        self.Close()


    def OnMenuAboutClick(self, event):
        """
        Creates the About window.
        """
        about_frame = base.AboutFrame(self)
        label = "DataDeck v%s" % datadeck.__version__

        about_frame.datadeck_label.SetLabel(label)

        license = datadeck.__license_full__
        about_frame.license_text.AppendText(license)

        about_frame.SetSize(wx.Size(500, 400))
        about_frame.Centre()
        about_frame.Show()
    # </menu>

    # <library>
    def OnLibraryListItemSelected( self, event ):
        self.EnableLibraryButtons(True)

    def OnLibraryListItemDeselected( self, event ):
        self.EnableLibraryButtons(False)

    def EnableLibraryButtons(self, enable):
        self.m_library_info_button.Enable(enable)
        self.m_library_edit_button.Enable(enable)
        self.m_library_delete_button.Enable(enable)

    def OnButtonLibraryInfoClick( self, event ):
        selected_package = self.m_library.GetSelected()
        if selected_package:
            self.m_package.Info(selected_package)

    def OnButtonLibraryEditClick( self, event ):
        package = self.m_library.GetSelected()
        if package:
            print "Edit"

    def OnButtonLibraryDeleteClick( self, event ):
        package = self.m_library.GetSelected()
        message = "Are you sure you want to delete\nPackage " + package.name + "\ninstalled at " + package.installed_path + "?"
        box = wx.MessageDialog(self, message, "Delete?", wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
        overwrite = box.ShowModal()
        if overwrite == wx.ID_YES:
            self.m_library.Remove(package)
            self.m_library.Refresh()

    def OnButtonRefreshClick( self, event ):
        self.RefreshLibrary()

    def RefreshLibrary(self):
        self.m_library.Refresh()
    # </library>

    # <search>
    def OnSearchResultsListItemSelected( self, event ):
        self.EnableSearchResultsButtons(True)

    def OnSearchResultsListItemDeselected( self, event ):
        self.EnableSearchResultsButtons(False)

    def EnableSearchResultsButtons(self, enable):
        """
        Could not find a better name. Take care of two buttons that user sometimes do not need to click.
        Info and Download button can not be clicked if there are no packages selected. Their respective Click events
        take care whether there is a package selected or not, but in this way we drive the user experience, letting
        him/her know what to do after a package is searched.
        """
        self.m_info_button.Enable(enable)
        self.m_download_button.Enable(enable)


    def OnSearchTextKeyDown(self, event):
        """
        Simulate a click on Search button when Return is pressed
        """
        key_code = event.GetKeyCode()
        if key_code == wx.WXK_RETURN:
            self.OnButtonSearchClick(event)
        event.Skip()

    def OnButtonSearchClick( self, event ):
        """
        If there is text in the search text, launch a SearchOperation.
        """
        searched_value = self.m_search_text.GetValue()

        if not searched_value:
            return

        # clean eventual previous results
        self.EnableSearchResultsButtons(False)
        self.CleanSearchResults()

        datadeck.operations.SearchOperation(self, searched_value)
        print "Please wait..."

    def OnButtonDownloadClick(self, event):
        """
        Retrieve the currently selected package in the results list and launch a DownloadOperation
        for downloading it.
        """
        selected_package = self.m_search_results.GetSelected()
        if not selected_package:
            return
        self.m_package.Download(selected_package)


    def OnButtonInfoClick(self, event):
        """
        Retrieve the currently selected package in the results list and invoke the Package GUI
        for displaying information about it.
        """
        selected_package = self.m_search_results.GetSelected()
        if selected_package:
            self.m_package.Info(selected_package)

    def CleanSearchResults(self):
        self.m_search_results.Clear()


    def InsertSearchResultsList(self, package):
        """
        Insert a package in both the internal list and the GUI list. self.m_search_results_index ensures us that
        the two lists will be consistent.
        """
        self.m_search_results.Add(package)
    # </search>

    # <create>
    def PopulatePackageCreation(self, package):
        self.name_text.SetValue(package.name)
        self.url_text.SetValue(package.url)
        self.license_choice.SetSelection(datadeck.settings.Settings.licenses(package.license))
        self.author_text.SetValue(package.author)
        self.author_email_text.SetValue(package.author_email)
        self.notes_text.SetValue(package.notes)
        tags = ""
        for tag in package.tags:
            tags += tag + " "
        tags = tags.rstrip()
        self.tags_text.SetValue(tags)
        self.destination_dirpicker.SetPath(package.installed_path)


    # Save or Create a Package
    def OnButtonCreateClick( self, event ):
        package = dpm.package.Package()
        package.name = self.name_text.GetValue()
        package.title = package.name
        package.url = self.url_text.GetValue()
        package.license = self.m_package.Licenses(self.license_choice.GetSelection())
        package.author = self.author_text.GetValue()
        package.author_email = self.author_email_text.GetValue()
        package.notes = self.notes_text.GetValue()
        tags = self.tags_text.GetValue()
        tags = tags.rstrip()
        package.tags = tags.split(" ")
        path = self.destination_dirpicker.GetPath()
        overwrite_check = self.m_download.CheckPackageOverwrite(path, package)

        if overwrite_check:
            self.m_package.Create(package, path)
    # </create>

        # <console>
    def OnUpdateConsole(self, event):
        """
        Update the Console text
        """
        self.m_console.OnUpdateConsole(event)

    def OnProcessPendingEventsConsole(self, event):
        """
        Handle pending events
        """
        self.m_console.OnProcessPendingEventsConsole(event)

    def OnConsoleClearButtonClick(self, event):
        self.m_console.OnConsoleClearButtonClick(event)
        # </console>


    # <operations>
    def OnOperationMessageReceived(self, operation_message):
        """
        Handler for Operation Messages. Detect the type of the Message received and take care of it.
        According to the status of the Message, inform the user and update the GUI.
        See operations.py
        """
        self.m_operations.OnOperationMessageReceived(operation_message)

    def OnOperationsKillButtonClick( self, event ):
        """
        Kill all the currently running Operations
        """
        self.m_operations.KillOperations()
        # </operations>



    # <misc>
    def CheckConfig(self):
        #TODO: remove it when dpm 0.10 is officially released
        configuration = dpm.CONFIG
        if configuration.get("index:ckan", "ckan.url").find('ckan.net') > -1:
            configuration.set("index:ckan", "ckan.url", "http://thedatahub.org/api/")
            configuration.write(open(dpm.config.default_config_path, 'w'))

            configuration_path = dpm.config.default_config_path
            message = ("A dpm configuration file has been created on %s\n" +
                       "Please restart the program.") % (configuration_path)
            box = wx.MessageDialog(self, message, "dpm Configuration", wx.OK)
            box.ShowModal()
            box.Destroy()
            self.Close()
        import ConfigParser

        default_path = ""
        try:
            default_path = datadeck.settings.Settings.datadeck_default_path()
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            datadeck.settings.Settings.datadeck_default_path(os.path.expanduser('~'))
        if not default_path:
            datadeck.settings.Settings.datadeck_default_path(os.path.expanduser('~'))
    # </misc>
