__author__ = 'dgraziotin'
"""
Main GUI module. Implements search and download of packages.
Calls packagegui.py for displaying information about a package.
Manages Operations (~threads, see operations.py) and their messages.
Coding standard: http://www.wxpython.org/codeguidelines.php
"""
import os
import wx
import wx.xrc
import wx.lib.newevent
import dpm.package
import datadeck
import datadeck.settings
import datadeck.operations

import util.console
import util.operations
import util.download
import util.search
import util.package

import base
import settings


# for handling stdout and stderr on a TextCtrl
WX_STDOUT, EVT_STDOUT = wx.lib.newevent.NewEvent()

class MainGUI(base.DataDeckFrame):
    """
    The first GUI displayed when the program starts up.
    """
    def __init__(self):
        """
        Loads resources from XRC file, prepares internal structures representing search results,
        binds events, prepares the Console for receiving stdout and stderr.
        """
        base.DataDeckFrame.__init__(self, None)

        self.CheckConfig()

        #not handled well in autogenerated code, so they will be set here.

        self.m_search_results_listctrl.InsertColumn(0, "Name")
        self.m_search_results_listctrl.InsertColumn(1, "Short Description")
        self.m_search_results_listctrl.InsertColumn(2, "License")

        self.m_console = util.console.ConsoleUtil(self)
        self.m_operations = util.operations.OperationsUtil(self)
        self.m_download = util.download.DownloadUtil(self)
        self.m_package = util.package.PackageUtil(self)
        self.m_search_results_internal = util.search.SearchResults(self)

        self.m_console_text_timer = wx.Timer(self.m_console_text, -1)
        self.m_console_text.Bind(EVT_STDOUT, self.OnUpdateConsole)
        self.m_console_text.Bind(wx.EVT_TIMER, self.OnProcessPendingEventsConsole)

        self.license_choice.AppendItems(self.m_package.Licenses())
        self.destination_dirpicker.SetPath(datadeck.settings.Settings.datadeck_default_path())



        # Set up event handler for any worker thread results
        datadeck.operations.OPERATION_MESSAGE_HANDLER(self, self.OnOperationMessageReceived)

        # disable Download and Info buttons
        self.EnableButtons(False)
        self.SetSize(wx.Size(600, 650))
        self.Show(True)

    def OnButtonCreateClick( self, event ):
        package = dpm.package.Package()
        package.name = self.name_text.GetValue()
        package.title = package.name
        package.url = self.url_text.GetValue()
        package.license = self.m_package.Licenses(self.license_choice.GetSelection())
        package.author = self.author_text.GetValue()
        package.author_email = self.author_email_text.GetValue()
        package.notes = self.notes_text.GetValue()
        tags = self.tags_text.GetValue()
        package.tags = tags.split(" ")
        path = self.destination_dirpicker.GetPath()
        self.m_package.Create(package, path)


    def OnNameTextKillFocus( self, event ):
        """
        Called when focus is lost on package name, creation phase
        """
        name = self.name_text.GetValue()
        path = self.destination_dirpicker.GetPath()
        if not name or not path:
            return
        if self.m_package.AlreadyExists(path, name):
            print "WARNING: a package named " + name + " already exists. You will overwrite it."

    def OnOperationsKillButtonClick( self, event ):
        """
        Kill all the currently running Operations
        """
        self.m_operations.KillOperations()


    def OnUpdateConsole(self, event):
        """
        Update the Console text
        """
        self.m_console.OnUpdateConsole(event)

    def OnProcessPendingEventsConsole(self, event):
        """
        Handle pending events
        """
        self.m_console.OnProcessPendingEventsConsole(event)


    def OnOperationMessageReceived(self, operation_message):
        """
        Handler for Operation Messages. Detect the type of the Message received and take care of it.
        According to the status of the Message, inform the user and update the GUI.
        See operations.py
        """
        self.m_operations.OnOperationMessageReceived(operation_message)

    def OnSearchTextKeyDown(self, event):
        """
        Simulate a click on Search button when Return is pressed
        """
        key_code = event.GetKeyCode()
        if key_code == wx.WXK_RETURN:
            self.OnButtonSearchClick(event)
        event.Skip()

    def GetSelectedPackage(self):
        """
        Returns the currently selected package, fetched from the internal list
        """
        package_selected_index = self.m_search_results_listctrl.GetNextSelected(-1)
        if package_selected_index == -1:
            return None
        package_selected = self.m_search_results_internal.Get(package_selected_index)
        return package_selected

    def OnSearchResultsListItemSelected( self, event ):
        """
        If the user selects a package in the search result list,
        enable the Info and Download buttons, for processing it.
        """
        selected_item = event.m_itemIndex
        package_selected = self.m_search_results_internal.Get(selected_item)
        if package_selected:
            self.EnableButtons(True)

    def CleanSearchResults(self):
        """
        Clear both the GUI and the internal lists of packages found. Ready for a new search.
        """
        self.m_search_results_listctrl.DeleteAllItems()
        self.m_search_results_internal.Clear()


    def OnButtonSearchClick( self, event ):
        """
        If there is text in the search text, launch a SearchOperation.
        """
        searched_value = self.m_search_text.GetValue()

        if not searched_value:
            return

        # clean eventual previous results
        self.EnableButtons(False)
        self.CleanSearchResults()

        datadeck.operations.SearchOperation(self, searched_value)
        print "Please wait..."


    def OnButtonDownloadClick(self, event):
        """
        Retrieve the currently selected package in the results list and launch a DownloadOperation
        for downloading it.
        """
        selected_package = self.GetSelectedPackage()
        if not selected_package:
            return
        self.m_package.Download(selected_package)


    def OnButtonInfoClick(self, event):
        """
        Retrieve the currently selected package in the results list and invoke the Package GUI
        for displaying information about it.
        """
        selected_package = self.GetSelectedPackage()
        if selected_package:
            self.m_package.Info(selected_package)


    def OnConsoleClearButtonClick(self, event):
        self.m_console.OnConsoleClearButtonClick(event)

    def EnableButtons(self, enable):
        """
        Could not find a better name. Take care of two buttons that user sometimes do not need to click.
        Info and Download button can not be clicked if there are no packages selected. Their respective Click events
        take care whether there is a package selected or not, but in this way we drive the user experience, letting
        him/her know what to do after a package is searched.
        """
        self.m_info_button.Enable(enable)
        self.m_download_button.Enable(enable)


    def InsertSearchResultsList(self, package):
        """
        Insert a package in both the internal list and the GUI list. self.m_search_results_index ensures us that
        the two lists will be consistent.
        """
        name = package.metadata['name'] if package.metadata['name'] else "N/A"
        notes = package.metadata['notes'] if package.metadata['notes'] else "N/A"
        notes = notes[:30].replace("\n", " ").replace("\r", " ")
        license = package.metadata['license'] if package.metadata['license'] else "N/A"

        index = self.m_search_results_internal.Add(package)

        self.m_search_results_listctrl.InsertStringItem(index, name)
        self.m_search_results_listctrl.SetStringItem(index, 1, notes)
        self.m_search_results_listctrl.SetStringItem(index, 2, license)

        self.m_search_results_listctrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.m_search_results_listctrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.m_search_results_listctrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)


    def OnMenuAboutClick(self, event):
        """
        Creates the About window.
        """
        about_frame = base.AboutFrame(self)
        label = "DataDeck v%s" % datadeck.__version__

        about_frame.datadeck_label.SetLabel(label)

        license = datadeck.__license_full__
        about_frame.license_text.AppendText(license)

        about_frame.SetSize(wx.Size(500, 400))
        about_frame.Centre()
        about_frame.Show()


    def OnMenuExitClick(self, event):
        self.m_operations.KillOperations()
        self.Close()

    def OnMenuSettingsClick(self, event):
        settings.SettingsGUI(self).Show()


    def CheckConfig(self):
        #TODO: remove it when dpm 0.10 is officially released
        configuration = dpm.CONFIG
        if configuration.get("index:ckan", "ckan.url").find('ckan.net') > -1:
            configuration.set("index:ckan", "ckan.url", "http://thedatahub.org/api/")
            configuration.write(open(dpm.config.default_config_path, 'w'))

            configuration_path = dpm.config.default_config_path
            message = ("A dpm configuration file has been created on %s\n" +
                       "Please restart the program.") % (configuration_path)
            box = wx.MessageDialog(self, message, "dpm Configuration", wx.OK)
            box.ShowModal()
            box.Destroy()
            self.Close()
        import ConfigParser

        default_path = ""
        try:
            default_path = datadeck.settings.Settings.datadeck_default_path()
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            datadeck.settings.Settings.datadeck_default_path(os.path.expanduser('~'))
        if not default_path:
            datadeck.settings.Settings.datadeck_default_path(os.path.expanduser('~'))
